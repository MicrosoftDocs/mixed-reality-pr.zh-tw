---
ms.openlocfilehash: 487118403c2a8af1a6b54bc9aa9245fbe9d0568a
ms.sourcegitcommit: bec6029b2780c54cc04a45ef7ae5df3f5b4727c1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/01/2020
ms.locfileid: "96477053"
---
# <a name="project-settings"></a>[<span data-ttu-id="9b2ee-101">專案設定</span><span class="sxs-lookup"><span data-stu-id="9b2ee-101">Project settings</span></span>](#tab/project)

### <a name="1-review-the-common-porting-steps-listed-above"></a><span data-ttu-id="9b2ee-102">1. 檢查上面所列的常見移植步驟</span><span class="sxs-lookup"><span data-stu-id="9b2ee-102">1. Review the common porting steps listed above</span></span>

<span data-ttu-id="9b2ee-103">請檢查上面所列的常見步驟，以確定您的開發環境已正確設定。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-103">Review the common steps listed above to make sure your development environment is set up correctly.</span></span> <span data-ttu-id="9b2ee-104">在步驟 #3 中，如果您使用 Visual Studio 您應該選取使用 Unity 工作負載的 **遊戲開發** 。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-104">In step #3, if you're using Visual Studio you should select the **Game Development with Unity** workload.</span></span> <span data-ttu-id="9b2ee-105">您可以取消選取「Unity 編輯器選擇性」元件，因為您將在下一個步驟中安裝較新版本的 Unity。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-105">You may deselect the "Unity Editor optional" component since you'll be installing a newer version of Unity in the next step.</span></span>

### <a name="2-upgrade-to-the-latest-public-build-of-unity-with-windows-mr-support"></a><span data-ttu-id="9b2ee-106">2. 使用 Windows MR 支援升級至 Unity 的最新公開組建</span><span class="sxs-lookup"><span data-stu-id="9b2ee-106">2. Upgrade to the latest public build of Unity with Windows MR Support</span></span>
1. <span data-ttu-id="9b2ee-107">下載 Unity 的最新 [建議公用組建](../../install-the-tools.md) ，並提供混合現實支援。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-107">Download the latest [recommended public build of Unity](../../install-the-tools.md) with mixed reality support.</span></span>
2. <span data-ttu-id="9b2ee-108">開始之前，請先儲存專案的複本</span><span class="sxs-lookup"><span data-stu-id="9b2ee-108">Save a copy of your project before you get started</span></span>
3. <span data-ttu-id="9b2ee-109">如果您的專案是以較舊版本的 Unity 建立的，請參閱升級中 Unity 所提供的 [檔](https://docs.unity3d.com/Manual/UpgradeGuides.html) 。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-109">Review the [documentation](https://docs.unity3d.com/Manual/UpgradeGuides.html) available from Unity on upgrading if your project was built on an older version of Unity.</span></span>
4. <span data-ttu-id="9b2ee-110">遵循 Unity 網站上的 [指示](https://docs.unity3d.com/Manual/APIUpdater.html) ，以使用其自動 API 更新程式</span><span class="sxs-lookup"><span data-stu-id="9b2ee-110">Follow the [instructions](https://docs.unity3d.com/Manual/APIUpdater.html) on Unity's site for using their automatic API updater</span></span>
5. <span data-ttu-id="9b2ee-111">檢查並查看是否有其他需要進行的變更，讓您的專案執行，並處理任何剩餘的錯誤和警告。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-111">Check and see if there are additional changes that you need to make to get your project running, and work through any remaining errors and warnings.</span></span> 

> [!Note] 
> <span data-ttu-id="9b2ee-112">如果您有相依的中介軟體，請確認您使用的是最新版本 () 的步驟3中的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-112">If you have middleware that you depend on, check that you're using the latest release (more details in step 3 below).</span></span>

### <a name="3-upgrade-your-middleware-to-the-latest-versions"></a><span data-ttu-id="9b2ee-113">3. 將中介軟體升級至最新版本</span><span class="sxs-lookup"><span data-stu-id="9b2ee-113">3. Upgrade your middleware to the latest versions</span></span>

<span data-ttu-id="9b2ee-114">使用任何 Unity 更新時，您很可能需要更新您的遊戲或應用程式所依賴的一或多個中介軟體套件。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-114">With any Unity update, there's a good chance that you'll need to update one or more middleware packages that your game or application depends on.</span></span> <span data-ttu-id="9b2ee-115">此外，與最新的中介軟體保持在最新狀態，可提高移植程式其餘部分的成功機率。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-115">Additionally, being up to date with the latest middleware increases the likelihood of success throughout the rest of the porting process.</span></span>

### <a name="4-target-your-application-to-run-on-win32"></a><span data-ttu-id="9b2ee-116">4. 以您的應用程式為目標在 Win32 上執行</span><span class="sxs-lookup"><span data-stu-id="9b2ee-116">4. Target your application to run on Win32</span></span>

<span data-ttu-id="9b2ee-117">從 Unity 應用程式內：</span><span class="sxs-lookup"><span data-stu-id="9b2ee-117">From inside your Unity application:</span></span>

* <span data-ttu-id="9b2ee-118">流覽至檔案 > 組建設定</span><span class="sxs-lookup"><span data-stu-id="9b2ee-118">Navigate to File -> Build Settings</span></span>
* <span data-ttu-id="9b2ee-119">選取 [電腦、Mac、Linux 獨立]</span><span class="sxs-lookup"><span data-stu-id="9b2ee-119">Select "PC, Mac, Linux Standalone"</span></span>
* <span data-ttu-id="9b2ee-120">將目標平臺設定為 "Windows"</span><span class="sxs-lookup"><span data-stu-id="9b2ee-120">Set target platform to "Windows"</span></span>
* <span data-ttu-id="9b2ee-121">將 [架構] 設定為 [x86] 選取 [切換平臺]</span><span class="sxs-lookup"><span data-stu-id="9b2ee-121">Set architecture to "x86" Select "Switch Platform"</span></span>

> [!NOTE] 
> <span data-ttu-id="9b2ee-122">如果您的應用程式對裝置特定服務具有任何相依性，例如從串流進行比對，您必須在此步驟停用它們。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-122">If your application has any dependencies on device-specific services, such as match making from Steam, you'll need to disable them at this step.</span></span> <span data-ttu-id="9b2ee-123">您可以連結到 Windows 稍後提供的對等服務。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-123">You can hook up to the equivalent services that Windows provides later on.</span></span>

### <a name="5-setup-your-windows-mixed-reality-hardware"></a><span data-ttu-id="9b2ee-124">5. 設定您的 Windows Mixed Reality 硬體</span><span class="sxs-lookup"><span data-stu-id="9b2ee-124">5. Setup your Windows Mixed Reality hardware</span></span>
1. <span data-ttu-id="9b2ee-125">在[沉浸式耳機設定](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/before-you-start
)中檢查步驟</span><span class="sxs-lookup"><span data-stu-id="9b2ee-125">Review steps in [Immersive headset setup](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/before-you-start
)</span></span>
2. <span data-ttu-id="9b2ee-126">瞭解如何 [使用 Windows Mixed Reality](../../platform-capabilities-and-apis/using-the-windows-mixed-reality-simulator.md) 模擬器和 [導覽 Windows Mixed Reality 首頁](../../../discover/navigating-the-windows-mixed-reality-home.md)</span><span class="sxs-lookup"><span data-stu-id="9b2ee-126">Learn about [Using the Windows Mixed Reality simulator](../../platform-capabilities-and-apis/using-the-windows-mixed-reality-simulator.md) and [Navigating the Windows Mixed Reality home](../../../discover/navigating-the-windows-mixed-reality-home.md)</span></span>

### <a name="6-target-your-application-to-run-on-windows-mixed-reality"></a><span data-ttu-id="9b2ee-127">6. 將應用程式設為目標，以在 Windows Mixed Reality 上執行</span><span class="sxs-lookup"><span data-stu-id="9b2ee-127">6. Target your application to run on Windows Mixed Reality</span></span>
1. <span data-ttu-id="9b2ee-128">首先，您必須移除或有條件地編譯特定的 VR SDK 專屬的任何其他程式庫支援。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-128">First, you must remove or conditionally compile out any other library support specific to a particular VR SDK.</span></span> <span data-ttu-id="9b2ee-129">這些資產經常會變更專案的設定和屬性，其方式與其他的 VR Sdk （例如 Windows Mixed Reality）不相容。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-129">Those assets frequently change settings and properties on your project in ways that are incompatible with other VR SDKs, such as Windows Mixed Reality.</span></span>
    * <span data-ttu-id="9b2ee-130">例如，如果您的專案參考 SteamVR SDK，您將需要更新您的專案，改為使用 Unity 的通用 VR Api 來支援 Windows Mixed Reality 和 SteamVR。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-130">For example, if your project references the SteamVR SDK, you'll need to update your project to instead use Unity's common VR APIs that support both Windows Mixed Reality and SteamVR.</span></span>
    * <span data-ttu-id="9b2ee-131">有條件地排除其他 VR Sdk 的特定步驟即將推出。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-131">Specific steps for conditionally excluding other VR SDKs are coming soon.</span></span>
2. <span data-ttu-id="9b2ee-132">在您的 Unity 專案中，以 [WINDOWS 10 SDK 為目標](../../unity/tutorials/holograms-100.md#target-windows-10-sdk)</span><span class="sxs-lookup"><span data-stu-id="9b2ee-132">In your Unity project, [target the Windows 10 SDK](../../unity/tutorials/holograms-100.md#target-windows-10-sdk)</span></span>
3. <span data-ttu-id="9b2ee-133">針對每個場景 [設定相機](../../unity/tutorials/holograms-100.md#chapter-2---setup-the-camera)</span><span class="sxs-lookup"><span data-stu-id="9b2ee-133">For each scene, [setup the camera](../../unity/tutorials/holograms-100.md#chapter-2---setup-the-camera)</span></span>

### <a name="7-use-the-stage-to-place-content-on-the-floor"></a><span data-ttu-id="9b2ee-134">7. 使用階段將內容放在樓層上</span><span class="sxs-lookup"><span data-stu-id="9b2ee-134">7. Use the stage to place content on the floor</span></span>

<span data-ttu-id="9b2ee-135">您可以跨多種 [體驗規模](../../../design/coordinate-systems.md)來建立混合的現實體驗。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-135">You can build Mixed Reality experiences across a wide range of [experience scales](../../../design/coordinate-systems.md).</span></span>

<span data-ttu-id="9b2ee-136">如果您要移植的是 **大規模的體驗**，您必須確定 Unity 已設定為 **固定** 的追蹤空間類型：</span><span class="sxs-lookup"><span data-stu-id="9b2ee-136">If you're porting a **seated-scale experience**, you must ensure Unity is set to the **Stationary** tracking space type:</span></span>

```cs
XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);
```

<span data-ttu-id="9b2ee-137">上述程式碼會設定 Unity 的全局座標系統，以追蹤 [固定的參考框架](../../../design/coordinate-systems.md#spatial-coordinate-systems)。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-137">This above code sets Unity's world coordinate system to track the [stationary frame of reference](../../../design/coordinate-systems.md#spatial-coordinate-systems).</span></span> <span data-ttu-id="9b2ee-138">在「固定追蹤」模式中，放在「相機」預設位置前方之編輯器中的內容 (轉寄是-Z) 會在應用程式啟動時出現在使用者前面。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-138">In the Stationary tracking mode, content placed in the editor just in front of the camera's default location (forward is -Z) appears in front of the user when the app launches.</span></span> <span data-ttu-id="9b2ee-139">若要 recenter 使用者的原始來源，您可以呼叫 Unity 的 [XR。InputTracking. Recenter](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html) 方法。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-139">To recenter the user's seated origin, you can call Unity's [XR.InputTracking.Recenter](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html) method.</span></span>

<span data-ttu-id="9b2ee-140">如果您要移植 **大規模體驗** 或 **房間規模的體驗**，您將會放置相對於樓層的內容。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-140">If you're porting a **standing-scale experience** or **room-scale experience**, you'll be placing content relative to the floor.</span></span> <span data-ttu-id="9b2ee-141">您可以使用 **[空間階段](../../../design/coordinate-systems.md#spatial-coordinate-systems)**（代表使用者定義的樓層層級來源和選擇性的空間界限），在第一次執行期間設定使用者的樓層。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-141">You reason about the user's floor using the **[spatial stage](../../../design/coordinate-systems.md#spatial-coordinate-systems)**, which represents the user's defined floor-level origin and optional room boundary, set up during first run.</span></span> <span data-ttu-id="9b2ee-142">針對這些經驗，您必須確定 Unity 已設定為 **RoomScale** 追蹤空間類型。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-142">For these experiences, you must ensure Unity is set to the **RoomScale** tracking space type.</span></span> <span data-ttu-id="9b2ee-143">雖然 RoomScale 是預設值，但您會想要明確進行設定，並確保您會得到 true，以找出使用者將電腦移離他們所校正之房間的情況：</span><span class="sxs-lookup"><span data-stu-id="9b2ee-143">While RoomScale is the default, you'll want to set it explicitly and ensure you get back true, to catch situations where the user has moved their computer away from the room they calibrated:</span></span>

```cs
if (XRDevice.SetTrackingSpaceType(TrackingSpaceType.RoomScale))
{
    // RoomScale mode was set successfully.  App can now assume that y=0 in Unity world coordinate represents the floor.
}
else
{
    // RoomScale mode was not set successfully.  App cannot make assumptions about where the floor plane is.
}
```

<span data-ttu-id="9b2ee-144">一旦您的應用程式成功設定 RoomScale 追蹤空間類型，放在 y = 0 平面上的內容就會出現在樓層上。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-144">Once your app successfully sets the RoomScale tracking space type, content placed on the y=0 plane will appear on the floor.</span></span> <span data-ttu-id="9b2ee-145"> (0、0、0) 的原點將會是使用者在房間設定期間勇敢面對考驗的特定位置，而-Z 代表在安裝期間所面對的正向方向。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-145">The origin at (0, 0, 0) will be the specific place on the floor where the user stood during room setup, with -Z representing the forward direction they were facing during setup.</span></span>

<span data-ttu-id="9b2ee-146">在腳本程式碼中，您可以呼叫 UnityEngine 的 TryGetGeometry 方法，以取得界限多邊形，並指定 TrackedArea 的界限類型。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-146">In script code, you can then call the TryGetGeometry method on you're the UnityEngine.Experimental.XR.Boundary type to get a boundary polygon, specifying a boundary type of TrackedArea.</span></span> <span data-ttu-id="9b2ee-147">如果使用者定義了界限， (您取得頂點) 的清單，就可以安全地將 **房間規模的體驗** 提供給使用者，讓他們可以在您建立的場景周圍四處進行。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-147">If the user defined a boundary (you get back a list of vertices), it's safe to deliver a **room-scale experience** to the user, where they can walk around the scene you create.</span></span>

<span data-ttu-id="9b2ee-148">當使用者進行方法時，系統會自動呈現界限。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-148">The system will automatically render the boundary when the user approaches it.</span></span> <span data-ttu-id="9b2ee-149">您的應用程式不需要使用此多邊形來呈現界限本身。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-149">Your app does not need to use this polygon to render the boundary itself.</span></span>

<span data-ttu-id="9b2ee-150">如需詳細資訊，請參閱 [Unity 頁面中的座標系統](../../unity/coordinate-systems-in-unity.md) 。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-150">For more information, see the [Coordinate systems in Unity](../../unity/coordinate-systems-in-unity.md) page.</span></span>

<!-- Some applications use a rectangle to constrain their interaction. Retrieving the largest inscribed rectangle is not directly supported in the UWP API or Unity. The example code linked to below shows how to find a rectangle within the traced bounds. It's heuristic-based so may not find the optimal solution, however, results are consistent with expectations. Parameters in the algorithm can be tuned to find more precise results at the cost of processing time. The algorithm is in a fork of the Mixed Reality Toolkit that uses the 5.6 preview MRTP version of Unity. This isn't publicly available. The code should be directly usable in 2017.2 and higher versions of Unity. The code will be ported to the current MRTK in the near future. -->

<span data-ttu-id="9b2ee-151">結果範例：</span><span class="sxs-lookup"><span data-stu-id="9b2ee-151">Example of results:</span></span>

![結果範例](../../porting-apps/images/largestrectangle-400px.jpg)

<span data-ttu-id="9b2ee-153">演算法是根據 Daniel Smilkov：[多邊形中最大矩形](https://d3plus.org/blog/behind-the-scenes/2014/07/08/largest-rect/)的 blog</span><span class="sxs-lookup"><span data-stu-id="9b2ee-153">Algorithm is based on a blog by Daniel Smilkov: [Largest rectangle in a polygon](https://d3plus.org/blog/behind-the-scenes/2014/07/08/largest-rect/)</span></span>

### <a name="8-work-through-your-input-model"></a><span data-ttu-id="9b2ee-154">8. 完成輸入模型的工作</span><span class="sxs-lookup"><span data-stu-id="9b2ee-154">8. Work through your input model</span></span>

<span data-ttu-id="9b2ee-155">以現有 HMD 為目標的每個遊戲或應用程式將會有一組其處理的輸入、體驗所需的輸入類型，以及它所呼叫以取得這些輸入的特定 Api。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-155">Each game or application targeting an existing HMD will have a set of inputs that it handles, types of inputs that it needs for the experience, and specific APIs that it calls to get those inputs.</span></span> <span data-ttu-id="9b2ee-156">我們致力於嘗試使其盡可能簡單明瞭，以充分利用 Windows Mixed Reality 中提供的輸入。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-156">We've invested in trying to make it as simple and straightforward as possible to take advantage of the inputs available in Windows Mixed Reality.</span></span>

<span data-ttu-id="9b2ee-157">請閱讀相鄰索引標籤中 Unity 的《 [輸入移植指南》](https://docs.microsoft.com/windows/mixed-reality/develop/porting-apps/porting-guides?tabs=input) ，以取得 Windows Mixed Reality 如何公開輸入的詳細資料，以及該如何對應至您的應用程式目前所能執行的作業。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-157">Read through the [input porting guide for Unity](https://docs.microsoft.com/windows/mixed-reality/develop/porting-apps/porting-guides?tabs=input) in the adjacent tab for details of how Windows Mixed Reality exposes input, and how that maps to what your application may do today.</span></span>

### <a name="9-performance-testing-and-tuning"></a><span data-ttu-id="9b2ee-158">9. 效能測試和微調</span><span class="sxs-lookup"><span data-stu-id="9b2ee-158">9. Performance testing and tuning</span></span>

<span data-ttu-id="9b2ee-159">Windows Mixed Reality 將可在各式各樣的裝置上使用，範圍從高終端遊戲電腦到廣大市場主流電腦都有。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-159">Windows Mixed Reality will be available on a broad class of devices, ranging from high end gaming PCs, down to broad market mainstream PCs.</span></span> <span data-ttu-id="9b2ee-160">根據您的目標市場，您應用程式的可用計算和圖形預算有很大的差異。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-160">Depending on what market you're targeting, there's a significant difference in the available compute and graphics budgets for your application.</span></span> <span data-ttu-id="9b2ee-161">在此移植練習期間，您可能會運用高階電腦，而且您的應用程式可以使用大量的計算和圖形預算。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-161">During this porting exercise, you're likely leveraging a premium PC, and have had significant compute and graphics budgets available to your app.</span></span> <span data-ttu-id="9b2ee-162">如果您想要讓您的應用程式可供更廣大的物件使用，您應該在想 [要作為目標的代表性硬體](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)上測試及分析您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-162">If you wish to make your app available to a broader audience, you should test and profile your app on [the representative hardware that you wish to target](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>

<span data-ttu-id="9b2ee-163">[Unity](https://docs.unity3d.com/Manual/Profiler.html)和[Visual Studio](https://docs.microsoft.com/visualstudio/profiling/index)都包含效能分析工具，以及[Microsoft](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)與[Intel](https://software.intel.com/articles/vr-content-developer-guide)發行有關效能分析和優化的指導方針。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-163">Both [Unity](https://docs.unity3d.com/Manual/Profiler.html) and [Visual Studio](https://docs.microsoft.com/visualstudio/profiling/index) include performance profilers, and both [Microsoft](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) and [Intel](https://software.intel.com/articles/vr-content-developer-guide) publish guidelines on performance profiling and optimization.</span></span> <span data-ttu-id="9b2ee-164">在 [瞭解混合現實的效能](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)時，有廣泛的效能討論可供您使用。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-164">There's an extensive discussion of performance available at [Understanding Performance for Mixed Reality](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md).</span></span> <span data-ttu-id="9b2ee-165">此外，unity 的 [效能建議](../../unity/performance-recommendations-for-unity.md)下會有 unity 的特定詳細資料。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-165">Further, there are specific details for Unity under [Performance Recommendations for Unity](../../unity/performance-recommendations-for-unity.md).</span></span>

# <a name="input-mapping"></a>[<span data-ttu-id="9b2ee-166">輸入對應</span><span class="sxs-lookup"><span data-stu-id="9b2ee-166">Input mapping</span></span>](#tab/input)

<span data-ttu-id="9b2ee-167">您可以使用下列兩種方法之一來將輸入邏輯移植到 Windows Mixed Reality： Unity 的一般輸入。跨多個平臺的 GetButton/GetAxis Api，或 Windows 特定的 XR。Wsa。輸入 Api，專為運動控制器和 HoloLens 手提供更豐富的資料。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-167">You can port your input logic to Windows Mixed Reality using one of two approaches, Unity's general Input.GetButton/GetAxis APIs that span across multiple platforms, or the Windows-specific XR.WSA.Input APIs that offer richer data specifically for motion controllers and HoloLens hands.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9b2ee-168">如果您使用 HP-UX 的 G2 控制器，請參閱 [這篇文章](../../unity/unity-reverb-g2-controllers.md) 以取得其他輸入對應指示。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-168">If your using HP Reverb G2 controllers, please refer to [this article](../../unity/unity-reverb-g2-controllers.md) for additional input mapping instructions.</span></span>

## <a name="unity-xr-input-apis"></a><span data-ttu-id="9b2ee-169">Unity XR 輸入 Api</span><span class="sxs-lookup"><span data-stu-id="9b2ee-169">Unity XR input APIs</span></span>

<span data-ttu-id="9b2ee-170">針對新的專案，我們建議您從頭開始使用新的 XR 輸入 Api。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-170">For new projects, we recommend using the new XR input APIs from the beginning.</span></span> 

<span data-ttu-id="9b2ee-171">您可以在這裡找到有關 [XR api](https://docs.unity3d.com/Manual/xr_input.html)的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-171">You can find more information about the [XR APIs here](https://docs.unity3d.com/Manual/xr_input.html).</span></span>

## <a name="inputgetbuttongetaxis-apis"></a><span data-ttu-id="9b2ee-172">GetButton/GetAxis Api</span><span class="sxs-lookup"><span data-stu-id="9b2ee-172">Input.GetButton/GetAxis APIs</span></span>

<span data-ttu-id="9b2ee-173">Unity 目前使用其一般輸入. GetButton/GetAxis Api 來公開 [OCULUS SDK](https://docs.unity3d.com/Manual/OculusControllers.html) 和 [OpenVR SDK](https://docs.unity3d.com/Manual/OpenVRControllers.html)的輸入。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-173">Unity currently uses its general Input.GetButton/Input.GetAxis APIs to expose input for [the Oculus SDK](https://docs.unity3d.com/Manual/OculusControllers.html) and [the OpenVR SDK](https://docs.unity3d.com/Manual/OpenVRControllers.html).</span></span> <span data-ttu-id="9b2ee-174">如果您的應用程式已經使用這些 Api 進行輸入，這是在 Windows Mixed Reality 中支援移動控制器最簡單的路徑：您應該只需要重新對應輸入管理員中的按鈕和軸。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-174">If your apps are already using these APIs for input, this is the easiest path for supporting motion controllers in Windows Mixed Reality: you should just need to remap buttons and axes in the Input Manager.</span></span>

<span data-ttu-id="9b2ee-175">如需詳細資訊，請參閱 [unity 按鈕/軸對應表](../../unity/gestures-and-motion-controllers-in-unity.md#unity-buttonaxis-mapping-table) 和 [通用 Unity api 的總覽](../../unity/gestures-and-motion-controllers-in-unity.md#common-unity-apis-inputgetbuttongetaxis)。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-175">For more information, see the [Unity button/axis mapping table](../../unity/gestures-and-motion-controllers-in-unity.md#unity-buttonaxis-mapping-table) and the [overview of the common Unity APIs](../../unity/gestures-and-motion-controllers-in-unity.md#common-unity-apis-inputgetbuttongetaxis).</span></span>

## <a name="windows-specific-xrwsainput-apis"></a><span data-ttu-id="9b2ee-176">Windows 特定 XR。Wsa。輸入 Api</span><span class="sxs-lookup"><span data-stu-id="9b2ee-176">Windows-specific XR.WSA.Input APIs</span></span>

> [!CAUTION]
> <span data-ttu-id="9b2ee-177">如果您的專案使用任何 XR。WSA Api 在未來的 Unity 版本中，將會以 XR SDK 的方式來淘汰這些 Api。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-177">If your project is using any of the XR.WSA APIs, these are being phased out in favor of the XR SDK in future Unity releases.</span></span> <span data-ttu-id="9b2ee-178">針對新的專案，我們建議您從一開始就使用 XR SDK。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-178">For new projects, we recommend using the XR SDK from the beginning.</span></span> <span data-ttu-id="9b2ee-179">您可以在 [這裡找到 XR 輸入系統和 api](https://docs.unity3d.com/Manual/xr_input.html)的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-179">You can find more information about the [XR Input system and APIs here](https://docs.unity3d.com/Manual/xr_input.html).</span></span>

<span data-ttu-id="9b2ee-180">如果您的應用程式已經為每個平臺建立自訂輸入邏輯，您可以選擇使用 **UnityEngine. XR** 命名空間底下的 Windows 特定空間輸入 api。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-180">If your app already builds custom input logic for each platform, you can choose to use the Windows-specific spatial input APIs under the **UnityEngine.XR.WSA.Input** namespace.</span></span> <span data-ttu-id="9b2ee-181">這可讓您存取額外的資訊，例如位置精確度或來源種類，讓您可以在 HoloLens 上分辨手和控制器。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-181">This lets you access additional information, such as position accuracy or the source kind, letting you tell hands and controllers apart on HoloLens.</span></span>

> [!NOTE]
> <span data-ttu-id="9b2ee-182">如果您使用 HP-UX 的 G2 控制器，除了 **InteractionSource** 以外，所有輸入 api 仍可繼續運作，但會傳回 false，而不會傳回任何觸控板資料。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-182">If you're using HP Reverb G2 controllers, all input APIs will continue to work except for **InteractionSource.supportsTouchpad**, which will return false with no touchpad data.</span></span>

<span data-ttu-id="9b2ee-183">如需詳細資訊，請參閱 [UnityEngine. XR. 輸入 api 的總覽](../../unity/gestures-and-motion-controllers-in-unity.md#windows-specific-apis-xrwsainput)。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-183">For more information, see the [overview of the UnityEngine.XR.WSA.Input APIs](../../unity/gestures-and-motion-controllers-in-unity.md#windows-specific-apis-xrwsainput).</span></span>

## <a name="grip-pose-vs-pointing-pose"></a><span data-ttu-id="9b2ee-184">底姿勢與指標姿勢</span><span class="sxs-lookup"><span data-stu-id="9b2ee-184">Grip pose vs. pointing pose</span></span>

<span data-ttu-id="9b2ee-185">Windows Mixed Reality 支援各種外型規格中的運動控制器，每個控制器的設計各有不同之處，就是使用者的位置與應用程式在轉譯控制器時應使用的自然「向前」方向之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-185">Windows Mixed Reality supports motion controllers in a variety of form factors, with each controller's design differing in its relationship between the user's hand position and the natural "forward" direction that apps should use for pointing when rendering the controller.</span></span>

<span data-ttu-id="9b2ee-186">為了更妥善地表示這些控制器，您可以針對每個互動來源進行兩種調查：</span><span class="sxs-lookup"><span data-stu-id="9b2ee-186">To better represent these controllers, there are two kinds of poses you can investigate for each interaction source:</span></span>

* <span data-ttu-id="9b2ee-187">底框 **姿勢**，代表 HoloLens 所偵測到之掌上的位置，或是持有運動控制器的掌上。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-187">The **grip pose**, representing the location of either the palm of a hand detected by a HoloLens, or the palm holding a motion controller.</span></span>
    * <span data-ttu-id="9b2ee-188">在沉浸式耳機上，這個姿勢最適合用 **來呈現使用者手** 或 **使用者手中所持有的物件**，例如寶劍或機槍。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-188">On immersive headsets, this pose is best used to render **the user's hand** or **an object held in the user's hand**, such as a sword or gun.</span></span>
    * <span data-ttu-id="9b2ee-189">把手 **位置**：自然地按住控制器時的棕櫚距心，向左或向右調整以將位置置中置中。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-189">The **grip position**: The palm centroid when holding the controller naturally, adjusted left or right to center the position within the grip.</span></span>
    * <span data-ttu-id="9b2ee-190">底 **圖方向的右軸**：當您完全開啟手來形成平面的5形姿勢時，您的掌上光 (的光線會從左至右向前復原，從右邊的棕櫚) </span><span class="sxs-lookup"><span data-stu-id="9b2ee-190">The **grip orientation's Right axis**: When you completely open your hand to form a flat 5-finger pose, the ray that is normal to your palm (forward from left palm, backward from right palm)</span></span>
    * <span data-ttu-id="9b2ee-191">底圖 **方向的向前軸**：當您關閉手部分 (時，如同按住控制器) 一樣，也就是由非拇指手指所形成的電子管「轉寄」的光線。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-191">The **grip orientation's Forward axis**: When you close your hand partially (as if holding the controller), the ray that points "forward" through the tube formed by your non-thumb fingers.</span></span>
    * <span data-ttu-id="9b2ee-192">底圖 **方向的向上軸**：右邊和向前定義所隱含的向上軸。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-192">The **grip orientation's Up axis**: The Up axis implied by the Right and Forward definitions.</span></span>
    * <span data-ttu-id="9b2ee-193">您可以透過 Unity 的跨廠商輸入 API (XR 來存取抓住姿勢 **[。InputTracking](https://docs.unity3d.com/ScriptReference/XR.InputTracking.html)。GetLocalPosition/輪替**) 或透過 Windows 特定 API (**SourceState. SourcePose. TryGetPosition/旋轉**，要求底框姿勢) 。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-193">You can access the grip pose through either Unity's cross-vendor input API (**[XR.InputTracking](https://docs.unity3d.com/ScriptReference/XR.InputTracking.html).GetLocalPosition/Rotation**) or through the Windows-specific API (**sourceState.sourcePose.TryGetPosition/Rotation**, requesting the Grip pose).</span></span>
* <span data-ttu-id="9b2ee-194">**指標姿勢**，代表指向轉寄之控制器的秘訣。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-194">The **pointer pose**, representing the tip of the controller pointing forward.</span></span>
    * <span data-ttu-id="9b2ee-195">當您在呈現控制器模型本身時 **指向 UI** 時，最好使用這個姿勢來 raycast。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-195">This pose is best used to raycast when **pointing at UI** when you are rendering the controller model itself.</span></span>
    * <span data-ttu-id="9b2ee-196">目前，指標姿勢只能透過 Windows 特定 API 來使用 (**sourceState. sourcePose. TryGetPosition/旋轉**，要求指標姿勢) 。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-196">Currently, the pointer pose is available only through the Windows-specific API (**sourceState.sourcePose.TryGetPosition/Rotation**, requesting the Pointer pose).</span></span>

<span data-ttu-id="9b2ee-197">這些姿勢座標全都以 Unity 全局座標表示。</span><span class="sxs-lookup"><span data-stu-id="9b2ee-197">These pose coordinates are all expressed in Unity world coordinates.</span></span>
