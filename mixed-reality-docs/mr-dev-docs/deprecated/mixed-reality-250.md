---
title: MR 分享 250-HoloLens 和沉浸式耳機
description: 遵循此程式碼逐步解說，使用 Unity、Visual Studio、HoloLens 和 Windows Mixed Reality 耳機來瞭解在混合現實裝置之間共用全像投影的詳細資料。
author: keveleigh
ms.author: kurtie
ms.date: 10/22/2019
ms.topic: article
keywords: holotoolkit、mixedrealitytoolkit、mixedrealitytoolkit-unity、沉浸式、移動控制器、共用、xbox 控制器、網路、跨裝置
ms.openlocfilehash: 8b6711ab3ee833306742fe938dfa501dc5b4ed0e
ms.sourcegitcommit: d3a3b4f13b3728cfdd4d43035c806c0791d3f2fe
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/20/2021
ms.locfileid: "98580125"
---
# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="7ad17-104">MR Sharing 250：HoloLens 和沉浸式頭戴裝置</span><span class="sxs-lookup"><span data-stu-id="7ad17-104">MR Sharing 250: HoloLens and immersive headsets</span></span>

>[!NOTE]
><span data-ttu-id="7ad17-105">混合實境學院教學課程的設計是以 HoloLens (第 1 代) 和混合實境沉浸式頭戴裝置為準。</span><span class="sxs-lookup"><span data-stu-id="7ad17-105">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="7ad17-106">因此，對於仍在尋找這些裝置開發指引的開發人員而言，我們覺得這些教學課程很重要。</span><span class="sxs-lookup"><span data-stu-id="7ad17-106">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="7ad17-107">這些教學課程 **_不會_** 使用用於 HoloLens 2 的最新工具組或互動進行更新。</span><span class="sxs-lookup"><span data-stu-id="7ad17-107">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="7ad17-108">系統會保留這些資訊，以繼續在支援的裝置上運作。</span><span class="sxs-lookup"><span data-stu-id="7ad17-108">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="7ad17-109">已針對 HoloLens 2 公佈[一系列新的教學課程](../develop/unity/tutorials/mr-learning-base-01.md)。</span><span class="sxs-lookup"><span data-stu-id="7ad17-109">[A new series of tutorials](../develop/unity/tutorials/mr-learning-base-01.md) has been posted for HoloLens 2.</span></span>

<span data-ttu-id="7ad17-110">利用通用 Windows 平臺 (UWP) 的彈性，您可以輕鬆地建立跨多個裝置的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7ad17-110">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="7ad17-111">有了這種彈性，我們可以建立利用每部裝置優勢的體驗。</span><span class="sxs-lookup"><span data-stu-id="7ad17-111">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="7ad17-112">本教學課程將涵蓋在 HoloLens 和 Windows Mixed Reality 沉浸式耳機上執行的基本共用體驗。</span><span class="sxs-lookup"><span data-stu-id="7ad17-112">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="7ad17-113">這項內容最初是在華盛頓州西雅圖的 Microsoft Build 2017 會議中提供。</span><span class="sxs-lookup"><span data-stu-id="7ad17-113">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="7ad17-114">**在此教學課程中，我們將：**</span><span class="sxs-lookup"><span data-stu-id="7ad17-114">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="7ad17-115">使用 UNET 設定網路。</span><span class="sxs-lookup"><span data-stu-id="7ad17-115">Setup a network using UNET.</span></span>
* <span data-ttu-id="7ad17-116">跨混合現實裝置共用全像影像。</span><span class="sxs-lookup"><span data-stu-id="7ad17-116">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="7ad17-117">根據所使用的混合現實裝置，建立不同的應用程式視圖。</span><span class="sxs-lookup"><span data-stu-id="7ad17-117">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="7ad17-118">建立共用體驗，讓 HoloLens 使用者透過一些簡單的謎題引導沉浸式耳機使用者。</span><span class="sxs-lookup"><span data-stu-id="7ad17-118">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="7ad17-119">裝置支援</span><span class="sxs-lookup"><span data-stu-id="7ad17-119">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="7ad17-120">課程</span><span class="sxs-lookup"><span data-stu-id="7ad17-120">Course</span></span></th><th style="width:150px"> <span data-ttu-id="7ad17-121"><a href="/hololens/hololens1-hardware">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="7ad17-121"><a href="/hololens/hololens1-hardware">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="7ad17-122"><a href="../discover/immersive-headset-hardware-details.md">沉浸式頭戴裝置</a></span><span class="sxs-lookup"><span data-stu-id="7ad17-122"><a href="../discover/immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="7ad17-123">MR Sharing 250：HoloLens 和沉浸式頭戴裝置</span><span class="sxs-lookup"><span data-stu-id="7ad17-123">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="7ad17-124">✔️</span><span class="sxs-lookup"><span data-stu-id="7ad17-124">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="7ad17-125">✔️</span><span class="sxs-lookup"><span data-stu-id="7ad17-125">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="7ad17-126">在您開始使用 Intune 之前</span><span class="sxs-lookup"><span data-stu-id="7ad17-126">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="7ad17-127">必要條件</span><span class="sxs-lookup"><span data-stu-id="7ad17-127">Prerequisites</span></span>

* <span data-ttu-id="7ad17-128">具有 [必要開發工具](../develop/install-the-tools.md) 並 [設定為支援 Windows Mixed Reality 沉浸式耳機](/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)的 Windows 10 PC。</span><span class="sxs-lookup"><span data-stu-id="7ad17-128">A Windows 10 PC with the [necessary development tools](../develop/install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="7ad17-129">適用于您電腦的 Xbox 控制器。</span><span class="sxs-lookup"><span data-stu-id="7ad17-129">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="7ad17-130">至少一個 HoloLens 裝置和一個沉浸式耳機。</span><span class="sxs-lookup"><span data-stu-id="7ad17-130">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="7ad17-131">允許 UDP 廣播進行探索的網路。</span><span class="sxs-lookup"><span data-stu-id="7ad17-131">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="7ad17-132">專案檔</span><span class="sxs-lookup"><span data-stu-id="7ad17-132">Project files</span></span>

* <span data-ttu-id="7ad17-133">下載專案 [所需的](https://github.com/Microsoft/MixedReality250/archive/master.zip) 檔案。</span><span class="sxs-lookup"><span data-stu-id="7ad17-133">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="7ad17-134">將檔案解壓縮至容易記住的位置。</span><span class="sxs-lookup"><span data-stu-id="7ad17-134">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="7ad17-135">此專案需要 [Windows Mixed Reality 支援的 Unity 建議版本](../develop/install-the-tools.md)。</span><span class="sxs-lookup"><span data-stu-id="7ad17-135">This project requires the [a recommended version of Unity with Windows Mixed Reality support](../develop/install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="7ad17-136">如果您想要在下載之前查看原始程式碼， [可在 GitHub 上](https://github.com/Microsoft/MixedReality250)取得。</span><span class="sxs-lookup"><span data-stu-id="7ad17-136">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="7ad17-137">第1章-Hololens World</span><span class="sxs-lookup"><span data-stu-id="7ad17-137">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="7ad17-138">目標</span><span class="sxs-lookup"><span data-stu-id="7ad17-138">Objectives</span></span>

<span data-ttu-id="7ad17-139">請確定開發環境已準備好使用簡單的專案。</span><span class="sxs-lookup"><span data-stu-id="7ad17-139">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7ad17-140">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7ad17-140">What we will build</span></span>

<span data-ttu-id="7ad17-141">一種應用程式，會在 HoloLens 或 Windows Mixed Reality 沉浸式耳機上顯示全像投影。</span><span class="sxs-lookup"><span data-stu-id="7ad17-141">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="7ad17-142">步驟</span><span class="sxs-lookup"><span data-stu-id="7ad17-142">Steps</span></span>

* <span data-ttu-id="7ad17-143">開啟 Unity。</span><span class="sxs-lookup"><span data-stu-id="7ad17-143">Open Unity.</span></span>
    * <span data-ttu-id="7ad17-144">選取 [開啟]  。</span><span class="sxs-lookup"><span data-stu-id="7ad17-144">Select **Open**.</span></span>
    * <span data-ttu-id="7ad17-145">流覽至您解壓縮專案檔的位置。</span><span class="sxs-lookup"><span data-stu-id="7ad17-145">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="7ad17-146">按一下 [選擇資料夾]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-146">Click **Select Folder**.</span></span>
    * <span data-ttu-id="7ad17-147">*Unity 需要一些時間才會第一次處理專案。*</span><span class="sxs-lookup"><span data-stu-id="7ad17-147">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="7ad17-148">檢查 Unity 中是否已啟用 Mixed Reality。</span><span class="sxs-lookup"><span data-stu-id="7ad17-148">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="7ad17-149">開啟 [組建設定] 對話方塊， (**Control + Shift + B** 或 **File > 組建設定 ...** ]) 。</span><span class="sxs-lookup"><span data-stu-id="7ad17-149">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="7ad17-150">選取 **通用 Windows 平臺** 然後按一下 [ **切換平臺**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-150">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="7ad17-151">選取 [ **編輯>播放機設定**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-151">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="7ad17-152">在右側的 [偵測 **器** ] 面板中，展開 [ **XR 設定**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-152">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="7ad17-153">勾選 [ **支援虛擬實境** ] 方塊。</span><span class="sxs-lookup"><span data-stu-id="7ad17-153">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="7ad17-154">*Windows Mixed Reality 應為虛擬實境 SDK。*</span><span class="sxs-lookup"><span data-stu-id="7ad17-154">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="7ad17-155">建立場景。</span><span class="sxs-lookup"><span data-stu-id="7ad17-155">Create a scene.</span></span>
    * <span data-ttu-id="7ad17-156">在階層中， **以滑鼠右鍵** 按一下 [ **主要攝影機** ] 選取 [ **刪除**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-156">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="7ad17-157">從 **HoloToolkit > 輸入 > Prefabs** 將 **MixedRealityCameraParent** 拖曳至 **階層。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-157">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="7ad17-158">將全像影像新增至場景</span><span class="sxs-lookup"><span data-stu-id="7ad17-158">Add Holograms to the scene</span></span>
    * <span data-ttu-id="7ad17-159">從 **AppPrefabs** 將 **Skybox** 拖曳至 **場景視圖**。</span><span class="sxs-lookup"><span data-stu-id="7ad17-159">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="7ad17-160">從 **AppPrefabs** 將 **管理員** 拖曳至 **階層。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-160">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="7ad17-161">從 **AppPrefabs** 將 **島** 拖曳至 **階層。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-161">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="7ad17-162">儲存並建立</span><span class="sxs-lookup"><span data-stu-id="7ad17-162">Save And build</span></span>
    * <span data-ttu-id="7ad17-163">儲存 (**Control + S** 或 **File > 儲存場景**) </span><span class="sxs-lookup"><span data-stu-id="7ad17-163">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="7ad17-164">因為這是新的場景，所以您需要為它命名。</span><span class="sxs-lookup"><span data-stu-id="7ad17-164">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="7ad17-165">名稱並不重要，但我們使用 SharedMixedReality。</span><span class="sxs-lookup"><span data-stu-id="7ad17-165">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="7ad17-166">匯出至 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="7ad17-166">Export To Visual Studio</span></span>
    * <span data-ttu-id="7ad17-167">開啟 [組建] 功能表 (**Control + Shift + B** 或 **File > 組建設定**) </span><span class="sxs-lookup"><span data-stu-id="7ad17-167">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="7ad17-168">按一下 [ **新增開啟的場景]。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-168">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="7ad17-169">檢查 **Unity c # 專案**</span><span class="sxs-lookup"><span data-stu-id="7ad17-169">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="7ad17-170">按一下 [建置]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-170">Click **Build**.</span></span>
    * <span data-ttu-id="7ad17-171">在出現的 [檔案瀏覽器] 視窗中，建立名為 **App** 的新資料夾。</span><span class="sxs-lookup"><span data-stu-id="7ad17-171">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="7ad17-172">按一下 **應用程式** 資料夾。</span><span class="sxs-lookup"><span data-stu-id="7ad17-172">Single click the **App** folder.</span></span>
    * <span data-ttu-id="7ad17-173">按下 [ **選取資料夾]。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-173">Press **Select Folder.**</span></span>
    * <span data-ttu-id="7ad17-174">**等候組建完成**</span><span class="sxs-lookup"><span data-stu-id="7ad17-174">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="7ad17-175">在出現的 [檔案瀏覽器] 視窗中，流覽至 **應用程式** 資料夾。</span><span class="sxs-lookup"><span data-stu-id="7ad17-175">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="7ad17-176">按兩下 **SharedMixedReality .sln** 以啟動 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="7ad17-176">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="7ad17-177">從 Visual Studio 建立</span><span class="sxs-lookup"><span data-stu-id="7ad17-177">Build From Visual Studio</span></span>
    * <span data-ttu-id="7ad17-178">使用頂端工具列變更目標為 **Release** 和 **x86**。</span><span class="sxs-lookup"><span data-stu-id="7ad17-178">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="7ad17-179">按一下 [**本機電腦**] 旁邊的箭號，然後選取要部署到 HoloLens 的 **裝置**</span><span class="sxs-lookup"><span data-stu-id="7ad17-179">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="7ad17-180">按一下 [ **裝置** ] 旁的箭號，然後選取 [ **本機電腦** ] 以部署混合現實耳機。</span><span class="sxs-lookup"><span data-stu-id="7ad17-180">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="7ad17-181">按一下 [ **Debug->啟動但不調試** ] 或 [ **Control + F5** ] 以啟動應用程式。</span><span class="sxs-lookup"><span data-stu-id="7ad17-181">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7ad17-182">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7ad17-182">Digging into the code</span></span>

<span data-ttu-id="7ad17-183">在 [專案] 面板中，流覽至 [ **Assets\HoloToolkit\Input\Scripts\Utilities** ]，然後按兩下 [ **MixedRealityCameraManager.cs** ] 將它開啟。</span><span class="sxs-lookup"><span data-stu-id="7ad17-183">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="7ad17-184">**總覽：** MixedRealityCameraManager.cs 是一個簡單的腳本，可根據裝置來調整品質層級和背景設定。</span><span class="sxs-lookup"><span data-stu-id="7ad17-184">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="7ad17-185">這裡的金鑰是 HolographicSettings IsDisplayOpaque，可讓腳本偵測裝置是否為 HoloLens (IsDisplayOpaque 會傳回 false) 或沉浸式耳機 (IsDisplayOpaque 會傳回 true) 。</span><span class="sxs-lookup"><span data-stu-id="7ad17-185">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7ad17-186">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="7ad17-186">Enjoy your progress</span></span>

<span data-ttu-id="7ad17-187">此時，應用程式只會轉譯一個全像影像。</span><span class="sxs-lookup"><span data-stu-id="7ad17-187">At this point the application will just render a hologram.</span></span> <span data-ttu-id="7ad17-188">我們稍後會將互動新增至影像。</span><span class="sxs-lookup"><span data-stu-id="7ad17-188">We will add interaction to the hologram later.</span></span> <span data-ttu-id="7ad17-189">這兩個裝置都會轉譯相同的全像投影。</span><span class="sxs-lookup"><span data-stu-id="7ad17-189">Both devices will render the hologram the same.</span></span> <span data-ttu-id="7ad17-190">沉浸式耳機也會呈現藍色天空和雲端背景。</span><span class="sxs-lookup"><span data-stu-id="7ad17-190">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="7ad17-191">第2章-互動</span><span class="sxs-lookup"><span data-stu-id="7ad17-191">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="7ad17-192">目標</span><span class="sxs-lookup"><span data-stu-id="7ad17-192">Objectives</span></span>

<span data-ttu-id="7ad17-193">示範如何處理 Windows Mixed Reality 應用程式的輸入。</span><span class="sxs-lookup"><span data-stu-id="7ad17-193">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7ad17-194">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7ad17-194">What we will build</span></span>

<span data-ttu-id="7ad17-195">以第1章的應用程式為基礎，我們將新增功能，讓使用者能夠挑選全像，然後將它放在 HoloLens 的真實世界表面，或放在沉浸式耳機的虛擬資料表中。</span><span class="sxs-lookup"><span data-stu-id="7ad17-195">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="7ad17-196">**輸入複習：** 在 HoloLens 上，選取手勢是 **點擊**。</span><span class="sxs-lookup"><span data-stu-id="7ad17-196">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="7ad17-197">在沉浸式耳機上，我們將使用 Xbox 控制器上 **的按鈕。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-197">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="7ad17-198">如需詳細資訊，請參閱 [互動模型的總覽](../design/interaction-fundamentals.md)。</span><span class="sxs-lookup"><span data-stu-id="7ad17-198">For more information check out the [interaction model overview](../design/interaction-fundamentals.md).</span></span>

### <a name="steps"></a><span data-ttu-id="7ad17-199">步驟</span><span class="sxs-lookup"><span data-stu-id="7ad17-199">Steps</span></span>

* <span data-ttu-id="7ad17-200">新增輸入管理員</span><span class="sxs-lookup"><span data-stu-id="7ad17-200">Add Input manager</span></span>
    * <span data-ttu-id="7ad17-201">從 **HoloToolkit > 輸入 > Prefabs** 將 **InputManager** 拖曳 **到階層** 作為 **經理** 的子系。</span><span class="sxs-lookup"><span data-stu-id="7ad17-201">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="7ad17-202">從 **HoloToolkit > 輸入 > Prefabs > 資料指標** 將 **游標** 拖曳至 **階層。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-202">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="7ad17-203">新增空間對應</span><span class="sxs-lookup"><span data-stu-id="7ad17-203">Add Spatial Mapping</span></span>
    * <span data-ttu-id="7ad17-204">從 **HoloToolkit > SpatialMapping > Prefabs** 將 **SpatialMapping** 拖曳至 **階層。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-204">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="7ad17-205">新增虛擬 Playspace</span><span class="sxs-lookup"><span data-stu-id="7ad17-205">Add Virtual Playspace</span></span>
    * <span data-ttu-id="7ad17-206">在 **階層** 中展開 **MixedRealityCameraParent** 選取 **界限**</span><span class="sxs-lookup"><span data-stu-id="7ad17-206">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="7ad17-207">在 [偵測 **器**] 面板中，核取 [啟用 **界限**] 核取方塊</span><span class="sxs-lookup"><span data-stu-id="7ad17-207">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="7ad17-208">從 **AppPrefabs** 將 **VRRoom** 拖曳至 **階層。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-208">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="7ad17-209">新增 WorldAnchorManager</span><span class="sxs-lookup"><span data-stu-id="7ad17-209">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="7ad17-210">在 **[階層] 中選取**[ **管理員**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-210">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="7ad17-211">在 [偵測 **器**] 中，按一下 [ **新增元件**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-211">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="7ad17-212">輸入 **World 錨點管理員**。</span><span class="sxs-lookup"><span data-stu-id="7ad17-212">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="7ad17-213">選取 [ **世界錨點管理員** ] 將它加入。</span><span class="sxs-lookup"><span data-stu-id="7ad17-213">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="7ad17-214">將 TapToPlace 新增至島</span><span class="sxs-lookup"><span data-stu-id="7ad17-214">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="7ad17-215">在 **[階層] 中，** 展開 [ **島**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-215">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="7ad17-216">選取 [ **MixedRealityLand**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-216">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="7ad17-217">在 [偵測 **器**] 中，按一下 [ **新增元件**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-217">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="7ad17-218">輸入點一下 **以放置** 並選取它。</span><span class="sxs-lookup"><span data-stu-id="7ad17-218">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="7ad17-219">選取 **[在點處放置父系**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-219">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="7ad17-220">將 **放置位移** 設定為 **(0、0.1、0)**。</span><span class="sxs-lookup"><span data-stu-id="7ad17-220">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="7ad17-221">儲存並建立成先前的</span><span class="sxs-lookup"><span data-stu-id="7ad17-221">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7ad17-222">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7ad17-222">Digging into the code</span></span>

<span data-ttu-id="7ad17-223">**腳本 1-GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="7ad17-223">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="7ad17-224">在 [專案] 面板中，流覽至 [ **Assets\HoloToolkit\Input\Scripts\InputSources** ]，然後按兩下 [ **GamepadInput.cs** ] 將它開啟。</span><span class="sxs-lookup"><span data-stu-id="7ad17-224">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="7ad17-225">在 [專案] 面板中的相同路徑中，也按兩下 [ **InteractionSourceInputSource.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-225">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="7ad17-226">請注意，這兩個腳本都有一個通用的基類 BaseInputSource。</span><span class="sxs-lookup"><span data-stu-id="7ad17-226">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="7ad17-227">BaseInputSource 會保留對 InputManager 的參考，讓腳本能夠觸發事件。</span><span class="sxs-lookup"><span data-stu-id="7ad17-227">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="7ad17-228">在此情況下，InputClicked 事件是相關的。</span><span class="sxs-lookup"><span data-stu-id="7ad17-228">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="7ad17-229">當我們進入腳本2時，請務必記住這一點 TapToPlace。</span><span class="sxs-lookup"><span data-stu-id="7ad17-229">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="7ad17-230">在 GamePadInput 的案例中，我們會輪詢控制器上要按下的按鈕，然後引發 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="7ad17-230">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="7ad17-231">在 InteractionSourceInputSource 的案例中，我們會引發 InputClicked 事件以回應 TappedEvent。</span><span class="sxs-lookup"><span data-stu-id="7ad17-231">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="7ad17-232">**腳本 2-TapToPlace.cs**</span><span class="sxs-lookup"><span data-stu-id="7ad17-232">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="7ad17-233">在 [專案] 面板中，流覽至 [ **Assets\HoloToolkit\SpatialMapping\Scripts** ]，然後按兩下 [ **TapToPlace.cs** ] 將它開啟。</span><span class="sxs-lookup"><span data-stu-id="7ad17-233">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="7ad17-234">許多開發人員想要在建立全像的應用程式時執行的第一件事，就是移動帶有手勢輸入的全息影像</span><span class="sxs-lookup"><span data-stu-id="7ad17-234">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="7ad17-235">因此，我們已 endeavored 徹底批註此腳本。</span><span class="sxs-lookup"><span data-stu-id="7ad17-235">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="7ad17-236">在本教學課程中，有一些值得注意的事項。</span><span class="sxs-lookup"><span data-stu-id="7ad17-236">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="7ad17-237">首先，請注意，TapToPlace 會執行 IInputClickHandler。</span><span class="sxs-lookup"><span data-stu-id="7ad17-237">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="7ad17-238">IInputClickHandler 會公開函式，這些函式會處理 GamePadInput.cs 或 InteractionSourceInputSource.cs 所引發的 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="7ad17-238">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="7ad17-239">當 BaseInputSource 偵測到 click，而具有 TapToPlace 的物件處於焦點時，就會呼叫 OnInputClicked。</span><span class="sxs-lookup"><span data-stu-id="7ad17-239">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="7ad17-240">Airtapping 在 HoloLens 上或按下 Xbox 控制器上的按鈕將會觸發事件。</span><span class="sxs-lookup"><span data-stu-id="7ad17-240">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="7ad17-241">其次是在 update 中執行程式碼，以查看是否正在查看介面，因此我們可以將遊戲物件放在介面上，例如資料表。</span><span class="sxs-lookup"><span data-stu-id="7ad17-241">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="7ad17-242">沉浸式耳機沒有實際表面的概念，因此代表資料表 top (隆隆 > TableThingy > Cube) 的物件已標記 SpatialMapping 實體層，因此更新中的光線轉換將會與虛擬資料表上的資料衝突。</span><span class="sxs-lookup"><span data-stu-id="7ad17-242">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7ad17-243">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="7ad17-243">Enjoy your progress</span></span>

<span data-ttu-id="7ad17-244">這次您可以選取島來移動它。</span><span class="sxs-lookup"><span data-stu-id="7ad17-244">This time you can select the island to move it.</span></span> <span data-ttu-id="7ad17-245">在 HoloLens 上，您可以將島移至真實表面。</span><span class="sxs-lookup"><span data-stu-id="7ad17-245">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="7ad17-246">在沉浸式耳機中，您可以將島移至我們所加入的虛擬資料表。</span><span class="sxs-lookup"><span data-stu-id="7ad17-246">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="7ad17-247">第3章-共用</span><span class="sxs-lookup"><span data-stu-id="7ad17-247">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="7ad17-248">目標</span><span class="sxs-lookup"><span data-stu-id="7ad17-248">Objectives</span></span>

<span data-ttu-id="7ad17-249">確定已正確設定網路，並詳細說明如何在裝置之間共用空間錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-249">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7ad17-250">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7ad17-250">What we will build</span></span>

<span data-ttu-id="7ad17-251">我們會將專案轉換成多人的專案。</span><span class="sxs-lookup"><span data-stu-id="7ad17-251">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="7ad17-252">我們會將 UI 和邏輯新增至主機或加入會話。</span><span class="sxs-lookup"><span data-stu-id="7ad17-252">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="7ad17-253">HoloLens 使用者會在與雲端一起的會話中看到彼此，而且沉浸式耳機使用者在錨點附近有雲端。</span><span class="sxs-lookup"><span data-stu-id="7ad17-253">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="7ad17-254">沉浸式耳機中的使用者會看到 HoloLens 使用者相對於場景的原點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-254">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="7ad17-255">HoloLens 使用者將會在同一處看到島的全息圖。</span><span class="sxs-lookup"><span data-stu-id="7ad17-255">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="7ad17-256">要注意的是，沉浸式耳機中的使用者不會在這一章的島上，而是與 HoloLens 一樣的行為，而且會有鳥的鳥觀點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-256">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="7ad17-257">步驟</span><span class="sxs-lookup"><span data-stu-id="7ad17-257">Steps</span></span>

* <span data-ttu-id="7ad17-258">移除島和 VRRoom</span><span class="sxs-lookup"><span data-stu-id="7ad17-258">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="7ad17-259">在 **階層中，以** 滑鼠右鍵按一下 [**島**] 選取 [**刪除**]</span><span class="sxs-lookup"><span data-stu-id="7ad17-259">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="7ad17-260">在 **階層中，以** 滑鼠右鍵按一下 **VRRoom** 選取 [**刪除**]</span><span class="sxs-lookup"><span data-stu-id="7ad17-260">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="7ad17-261">新增 Usland</span><span class="sxs-lookup"><span data-stu-id="7ad17-261">Add Usland</span></span>
    * <span data-ttu-id="7ad17-262">從 **AppPrefabs** 將 **Usland** 拖曳至 **階層。**</span><span class="sxs-lookup"><span data-stu-id="7ad17-262">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="7ad17-263">從 **AppPrefabs** 將下列各項拖曳至 **階層：**</span><span class="sxs-lookup"><span data-stu-id="7ad17-263">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="7ad17-264">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="7ad17-264">**UNETSharingStage**</span></span>
    * <span data-ttu-id="7ad17-265">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="7ad17-265">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="7ad17-266">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="7ad17-266">**UIContainer**</span></span>
    * <span data-ttu-id="7ad17-267">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="7ad17-267">**DebugPanelButton**</span></span>
* <span data-ttu-id="7ad17-268">儲存並建立成先前的</span><span class="sxs-lookup"><span data-stu-id="7ad17-268">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7ad17-269">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7ad17-269">Digging into the code</span></span>

<span data-ttu-id="7ad17-270">在 [專案] 面板中，流覽至 [ **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** ]，然後按兩下 [ **UnetAnchorManager.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-270">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="7ad17-271">一個 HoloLens 與另一個 HoloLens 共用追蹤資訊的能力，使得這兩個裝置都可以共用相同的空間，幾乎神奇。</span><span class="sxs-lookup"><span data-stu-id="7ad17-271">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="7ad17-272">當有兩個以上的人員可以使用相同的數位資料共同作業時，混合現實的威力就會保持運作。</span><span class="sxs-lookup"><span data-stu-id="7ad17-272">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="7ad17-273">這段腳本中有幾點要指出：</span><span class="sxs-lookup"><span data-stu-id="7ad17-273">A few things to point out in this script:</span></span>

<span data-ttu-id="7ad17-274">在 start 函數中，請注意 **IsDisplayOpaque** 的檢查。</span><span class="sxs-lookup"><span data-stu-id="7ad17-274">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="7ad17-275">在此情況下，我們會假設已建立錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-275">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="7ad17-276">這是因為沉浸式耳機未公開匯入或匯出錨點的方式。</span><span class="sxs-lookup"><span data-stu-id="7ad17-276">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="7ad17-277">但是，如果我們是在 HoloLens 上執行，此腳本會在裝置之間執行共用錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-277">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="7ad17-278">啟動會話的裝置將會建立用於匯出的錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-278">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="7ad17-279">加入會話的裝置將會從啟動會話的裝置要求錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-279">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="7ad17-280">**出口：**</span><span class="sxs-lookup"><span data-stu-id="7ad17-280">**Exporting:**</span></span>

<span data-ttu-id="7ad17-281">當使用者建立會話時，NetworkDiscoveryWithAnchors 會呼叫 UNETAnchorManagers CreateAnchor 函數。</span><span class="sxs-lookup"><span data-stu-id="7ad17-281">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="7ad17-282">讓我們遵循 CreateAnchor flow。</span><span class="sxs-lookup"><span data-stu-id="7ad17-282">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="7ad17-283">我們一開始會先進行一些維護，並清除我們針對先前錨點收集到的任何資料。</span><span class="sxs-lookup"><span data-stu-id="7ad17-283">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="7ad17-284">然後檢查是否有要載入的快取錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-284">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="7ad17-285">錨定資料的長度通常是5到 20 MB，因此重複使用快取的錨點可以節省透過網路傳輸所需的資料量。</span><span class="sxs-lookup"><span data-stu-id="7ad17-285">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="7ad17-286">稍後我們會看到其運作方式。</span><span class="sxs-lookup"><span data-stu-id="7ad17-286">We'll see how this works a bit later.</span></span> <span data-ttu-id="7ad17-287">即使我們要重複使用錨點，但如果新的用戶端聯結沒有錨點，就需要讓錨點資料備妥。</span><span class="sxs-lookup"><span data-stu-id="7ad17-287">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="7ad17-288">說到準備錨點資料，WorldAnchorTransferBatch 類別會公開準備錨點資料以傳送至另一個裝置或應用程式的功能，以及匯入錨點資料的功能。</span><span class="sxs-lookup"><span data-stu-id="7ad17-288">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="7ad17-289">由於我們是在匯出路徑上，因此我們會將錨點新增至 WorldAnchorTransferBatch，並呼叫 ExportAsync 函式。</span><span class="sxs-lookup"><span data-stu-id="7ad17-289">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="7ad17-290">然後，ExportAsync 會在產生要匯出的資料時呼叫 WriteBuffer 回呼。</span><span class="sxs-lookup"><span data-stu-id="7ad17-290">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="7ad17-291">當匯出所有資料時，會呼叫 ExportComplete。</span><span class="sxs-lookup"><span data-stu-id="7ad17-291">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="7ad17-292">在 WriteBuffer 中，我們會將資料區塊新增至我們保留的匯出清單。</span><span class="sxs-lookup"><span data-stu-id="7ad17-292">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="7ad17-293">在 ExportComplete 中，我們會將清單轉換成陣列。</span><span class="sxs-lookup"><span data-stu-id="7ad17-293">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="7ad17-294">此外也會設定 AnchorName 變數，以觸發其他裝置要求錨點（如果沒有的話）。</span><span class="sxs-lookup"><span data-stu-id="7ad17-294">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="7ad17-295">在某些情況下，錨點將不會匯出或建立少量的資料，我們會再試一次。</span><span class="sxs-lookup"><span data-stu-id="7ad17-295">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="7ad17-296">我們在這裡直接呼叫 CreateAnchor。</span><span class="sxs-lookup"><span data-stu-id="7ad17-296">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="7ad17-297">匯出路徑中的最後一個函數是 AnchorFoundRemotely。</span><span class="sxs-lookup"><span data-stu-id="7ad17-297">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="7ad17-298">當另一部裝置找到錨點時，該裝置將會告訴主機，而主機會使用它作為信號，讓錨點成為「良好錨點」並可進行快取。</span><span class="sxs-lookup"><span data-stu-id="7ad17-298">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="7ad17-299">**進口：**</span><span class="sxs-lookup"><span data-stu-id="7ad17-299">**Importing:**</span></span>

<span data-ttu-id="7ad17-300">當 HoloLens 加入會話時，它需要匯入錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-300">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="7ad17-301">在 UNETAnchorManager 的 Update 函數中，會輪詢 AnchorName。</span><span class="sxs-lookup"><span data-stu-id="7ad17-301">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="7ad17-302">當錨點名稱變更時，匯入程式就會開始。</span><span class="sxs-lookup"><span data-stu-id="7ad17-302">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="7ad17-303">首先，我們會嘗試從本機錨點存放區載入具有指定名稱的錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-303">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="7ad17-304">如果已經有，我們可以使用它，而不需要再次下載資料。</span><span class="sxs-lookup"><span data-stu-id="7ad17-304">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="7ad17-305">如果沒有，則會呼叫 WaitForAnchor，以起始下載。</span><span class="sxs-lookup"><span data-stu-id="7ad17-305">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="7ad17-306">當下載完成時，會呼叫 NetworkTransmitter_dataReadyEvent。</span><span class="sxs-lookup"><span data-stu-id="7ad17-306">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="7ad17-307">這會通知更新迴圈使用下載的資料來呼叫 ImportAsync。</span><span class="sxs-lookup"><span data-stu-id="7ad17-307">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="7ad17-308">當匯入程式完成時，ImportAsync 會呼叫 ImportComplete。</span><span class="sxs-lookup"><span data-stu-id="7ad17-308">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="7ad17-309">如果匯入成功，錨點將會儲存在本機播放程式存放區中。</span><span class="sxs-lookup"><span data-stu-id="7ad17-309">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="7ad17-310">PlayerController.cs 實際上會呼叫 AnchorFoundRemotely，讓主機知道已建立良好的錨點。</span><span class="sxs-lookup"><span data-stu-id="7ad17-310">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7ad17-311">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="7ad17-311">Enjoy your progress</span></span>

<span data-ttu-id="7ad17-312">這次具有 HoloLens 的使用者將使用 UI 中的 [ **啟動會話** ] 按鈕來裝載會話。</span><span class="sxs-lookup"><span data-stu-id="7ad17-312">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="7ad17-313">其他使用者（在 HoloLens 或沉浸式耳機上）會選取會話，然後在 UI 中選取 [ **加入會話** ] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="7ad17-313">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="7ad17-314">如果您有多人使用 HoloLens 裝置，他們的標頭將會有 red cloud。</span><span class="sxs-lookup"><span data-stu-id="7ad17-314">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="7ad17-315">每個沉浸式耳機也會有一個藍色的雲端，但藍色的雲端不會在耳機上方，因為耳機不會嘗試尋找與 HoloLens 裝置相同的全局座標空間。</span><span class="sxs-lookup"><span data-stu-id="7ad17-315">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="7ad17-316">專案中的這個點是包含的共用應用程式;它並不會有太大的作用，而且可以作為基準。</span><span class="sxs-lookup"><span data-stu-id="7ad17-316">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="7ad17-317">在下一章中，我們將開始打造體驗，讓人們享受體驗。</span><span class="sxs-lookup"><span data-stu-id="7ad17-317">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="7ad17-318">若要取得有關共用體驗設計的進一步指引，請移至這裡。</span><span class="sxs-lookup"><span data-stu-id="7ad17-318">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="7ad17-319">第4章-深度和 teleporting</span><span class="sxs-lookup"><span data-stu-id="7ad17-319">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="7ad17-320">目標</span><span class="sxs-lookup"><span data-stu-id="7ad17-320">Objectives</span></span>

<span data-ttu-id="7ad17-321">滿足每種混合現實裝置的體驗。</span><span class="sxs-lookup"><span data-stu-id="7ad17-321">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7ad17-322">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7ad17-322">What we will build</span></span>

<span data-ttu-id="7ad17-323">我們將會更新應用程式，將沉浸式耳機使用者放在島上（具有沉浸式視圖）。</span><span class="sxs-lookup"><span data-stu-id="7ad17-323">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="7ad17-324">HoloLens 使用者仍會有此島的鳥眼睛。</span><span class="sxs-lookup"><span data-stu-id="7ad17-324">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="7ad17-325">每種裝置類型的使用者都可以看到出現在世界中的其他使用者。</span><span class="sxs-lookup"><span data-stu-id="7ad17-325">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="7ad17-326">比方說，沉浸式耳機使用者可以看到其他虛擬人偶在島上的其他路徑，並將 HoloLens 使用者視為大型雲端。</span><span class="sxs-lookup"><span data-stu-id="7ad17-326">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="7ad17-327">如果 HoloLens 使用者正在查看島，則沉浸式耳機使用者也會看到 HoloLens 使用者的注視光線游標。</span><span class="sxs-lookup"><span data-stu-id="7ad17-327">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="7ad17-328">HoloLens 使用者會看到島上的圖片，代表每個沉浸式耳機使用者。</span><span class="sxs-lookup"><span data-stu-id="7ad17-328">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="7ad17-329">**已更新沉浸式裝置的輸入：**</span><span class="sxs-lookup"><span data-stu-id="7ad17-329">**Updated Input for the Immersive device:**</span></span>

* <span data-ttu-id="7ad17-330">Xbox 控制器上的左緩衝和右緩衝按鈕會旋轉玩家</span><span class="sxs-lookup"><span data-stu-id="7ad17-330">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="7ad17-331">按住 Xbox 控制器上的 Y 按鈕將會啟用 [傳送](../discover/navigating-the-windows-mixed-reality-home.md#getting-around-your-home) 游標。</span><span class="sxs-lookup"><span data-stu-id="7ad17-331">Holding the Y button on the Xbox controller will enable a [teleport](../discover/navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="7ad17-332">當您放開 Y 按鈕時，如果游標具有旋轉箭號指標，則會傳送至游標的位置。</span><span class="sxs-lookup"><span data-stu-id="7ad17-332">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="7ad17-333">步驟</span><span class="sxs-lookup"><span data-stu-id="7ad17-333">Steps</span></span>

* <span data-ttu-id="7ad17-334">將 MixedRealityTeleport 新增至 MixedRealityCameraParent</span><span class="sxs-lookup"><span data-stu-id="7ad17-334">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="7ad17-335">在 **[階層] 中選取**[ **Usland**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-335">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="7ad17-336">在 [偵測 **器**] 中，啟用 **層級控制**。</span><span class="sxs-lookup"><span data-stu-id="7ad17-336">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="7ad17-337">在 **[階層] 中選取**[ **MixedRealityCameraParent**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-337">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="7ad17-338">在 [偵測 **器**] 中，按一下 [ **新增元件**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-338">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="7ad17-339">輸入 **Mixed Reality 傳送** ，然後選取它。</span><span class="sxs-lookup"><span data-stu-id="7ad17-339">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7ad17-340">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7ad17-340">Digging into the code</span></span>

<span data-ttu-id="7ad17-341">沉浸式耳機使用者將使用纜線行動網卡到他們的電腦，但我們的島大於纜線的長度。</span><span class="sxs-lookup"><span data-stu-id="7ad17-341">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="7ad17-342">為了彌補這一點，我們需要能夠在使用者的動作之外獨立移動相機。</span><span class="sxs-lookup"><span data-stu-id="7ad17-342">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="7ad17-343">請參閱 [ [緩和] 頁面](../design/comfort.md) ，以取得設計混合現實應用程式 (特定的自我運動和 locomotion) 的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="7ad17-343">Please see the [comfort page](../design/comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="7ad17-344">為了說明此程式，定義兩個詞彙將會很有説明。</span><span class="sxs-lookup"><span data-stu-id="7ad17-344">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="7ad17-345">首先， **dolly** 會是與使用者分開移動相機的物件。</span><span class="sxs-lookup"><span data-stu-id="7ad17-345">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="7ad17-346">**Dolly** 的子遊戲物件將會是 **主相機**。</span><span class="sxs-lookup"><span data-stu-id="7ad17-346">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="7ad17-347">主要相機會附加至使用者的標頭。</span><span class="sxs-lookup"><span data-stu-id="7ad17-347">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="7ad17-348">在 [專案] 面板中，流覽至 [ **Assets\AppPrefabs\Support\Scripts\GameLogic** ]，然後按兩下 [ **MixedRealityTeleport.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-348">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="7ad17-349">MixedRealityTeleport 有兩個作業。</span><span class="sxs-lookup"><span data-stu-id="7ad17-349">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="7ad17-350">首先，它會使用緩衝器來處理旋轉。</span><span class="sxs-lookup"><span data-stu-id="7ad17-350">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="7ad17-351">在 update 函數中，我們會在 LeftBumper 和 RightBumper 上輪詢 ' ButtonUp '。</span><span class="sxs-lookup"><span data-stu-id="7ad17-351">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="7ad17-352">GetButtonUp 只會在第一個畫面格上傳回 true。</span><span class="sxs-lookup"><span data-stu-id="7ad17-352">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="7ad17-353">如果已引發任一個按鈕，則我們知道使用者需要輪替。</span><span class="sxs-lookup"><span data-stu-id="7ad17-353">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="7ad17-354">當我們輪替時，請使用稱為「淡化控制項」的簡單腳本，淡出並淡出。</span><span class="sxs-lookup"><span data-stu-id="7ad17-354">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="7ad17-355">這麼做是為了防止使用者看見可能導致不適感的非自然移動。</span><span class="sxs-lookup"><span data-stu-id="7ad17-355">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="7ad17-356">淡入和淡出效果相當簡單。</span><span class="sxs-lookup"><span data-stu-id="7ad17-356">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="7ad17-357">在 **主要攝影機** 前面有黑色的間隙。</span><span class="sxs-lookup"><span data-stu-id="7ad17-357">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="7ad17-358">當您淡出時，會將 Alpha 值從0轉換成1。</span><span class="sxs-lookup"><span data-stu-id="7ad17-358">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="7ad17-359">這會逐漸產生四的黑色圖元來呈現和遮蔽背後的任何專案。</span><span class="sxs-lookup"><span data-stu-id="7ad17-359">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="7ad17-360">當您淡出時，我們會將 Alpha 值轉換回零。</span><span class="sxs-lookup"><span data-stu-id="7ad17-360">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="7ad17-361">當我們計算旋轉時，請注意我們會旋轉 **dolly** ，但會計算 **主要攝影機** 的旋轉。</span><span class="sxs-lookup"><span data-stu-id="7ad17-361">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="7ad17-362">這點很重要，因為 **主要相機** 離0、0、0愈遠，dolly 的旋轉就會從使用者的觀點來看，不精確。</span><span class="sxs-lookup"><span data-stu-id="7ad17-362">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="7ad17-363">事實上，如果您沒有繞著相機位置旋轉，則使用者會在 **dolly** 前後移動弧形，而不是旋轉。</span><span class="sxs-lookup"><span data-stu-id="7ad17-363">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="7ad17-364">MixedRealityTeleport 的第二個工作是處理 **dolly** 的移動。</span><span class="sxs-lookup"><span data-stu-id="7ad17-364">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="7ad17-365">這是在 SetWorldPosition 中完成。</span><span class="sxs-lookup"><span data-stu-id="7ad17-365">This is done in SetWorldPosition.</span></span> <span data-ttu-id="7ad17-366">SetWorldPosition 會採用所需的世界位置，也就是使用者想要 percieve 占的位置。</span><span class="sxs-lookup"><span data-stu-id="7ad17-366">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="7ad17-367">我們需要將 **dolly** 放在該位置減去 **主要攝影機** 的本機位置，因為該位移將會新增至每個畫面格。</span><span class="sxs-lookup"><span data-stu-id="7ad17-367">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="7ad17-368">第二個腳本會呼叫 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="7ad17-368">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="7ad17-369">讓我們來看看那個腳本。</span><span class="sxs-lookup"><span data-stu-id="7ad17-369">Let's look at that script.</span></span> <span data-ttu-id="7ad17-370">在 [專案] 面板中，流覽至 [ **Assets\AppPrefabs\Support\Scripts\GameLogic** ]，然後按兩下 [ **TeleportScript.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-370">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="7ad17-371">此腳本比 MixedRealityTeleport 更簡單。</span><span class="sxs-lookup"><span data-stu-id="7ad17-371">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="7ad17-372">腳本正在檢查 Xbox 控制器上的 Y 按鈕是否已關閉。</span><span class="sxs-lookup"><span data-stu-id="7ad17-372">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="7ad17-373">當按鈕關閉時，會轉譯傳送游標，而且腳本會將光線從使用者的注視位置轉換出來。</span><span class="sxs-lookup"><span data-stu-id="7ad17-373">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="7ad17-374">如果該光線與較多或較少指標的表面衝突，則會將介面視為適合用來傳送的介面，並且會啟用傳送游標上的動畫。</span><span class="sxs-lookup"><span data-stu-id="7ad17-374">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="7ad17-375">如果光線未與某個介面相較或更低，則會停用游標上的動畫。</span><span class="sxs-lookup"><span data-stu-id="7ad17-375">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="7ad17-376">當您放開 Y 按鈕，且光線的計算點是有效的位置時，腳本會使用與光線交集的位置來呼叫 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="7ad17-376">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7ad17-377">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="7ad17-377">Enjoy your progress</span></span>

<span data-ttu-id="7ad17-378">這次您將需要尋找 friend。</span><span class="sxs-lookup"><span data-stu-id="7ad17-378">This time you'll need to find a friend.</span></span>

<span data-ttu-id="7ad17-379">同樣地，具有 HoloLens 的使用者將會裝載一個會話。</span><span class="sxs-lookup"><span data-stu-id="7ad17-379">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="7ad17-380">其他使用者將加入會話。</span><span class="sxs-lookup"><span data-stu-id="7ad17-380">Other users will join the session.</span></span> <span data-ttu-id="7ad17-381">應用程式會將前三位使用者從島的三個路徑中的其中一個上的沉浸式耳機加入。</span><span class="sxs-lookup"><span data-stu-id="7ad17-381">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="7ad17-382">您可以隨時流覽這一節中的孤島。</span><span class="sxs-lookup"><span data-stu-id="7ad17-382">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="7ad17-383">要注意的詳細資料：</span><span class="sxs-lookup"><span data-stu-id="7ad17-383">Details to notice:</span></span>

1. <span data-ttu-id="7ad17-384">您可以看到雲端中的臉部，以協助可以沉浸使用者查看 HoloLens 使用者的期望方向。</span><span class="sxs-lookup"><span data-stu-id="7ad17-384">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="7ad17-385">島上的虛擬人偶具有旋轉的 necks。</span><span class="sxs-lookup"><span data-stu-id="7ad17-385">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="7ad17-386">他們不會遵循使用者正在做的事， (我們沒有這項資訊) 但可提供絕佳的體驗。</span><span class="sxs-lookup"><span data-stu-id="7ad17-386">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="7ad17-387">如果 HoloLens 使用者正在查看島，可以沉浸使用者可以看到他們的游標。</span><span class="sxs-lookup"><span data-stu-id="7ad17-387">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="7ad17-388">代表 HoloLens 使用者轉換陰影的雲端。</span><span class="sxs-lookup"><span data-stu-id="7ad17-388">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="7ad17-389">第5章-Finale</span><span class="sxs-lookup"><span data-stu-id="7ad17-389">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="7ad17-390">目標</span><span class="sxs-lookup"><span data-stu-id="7ad17-390">Objectives</span></span>

<span data-ttu-id="7ad17-391">建立兩個裝置類型之間的共同作業互動體驗。</span><span class="sxs-lookup"><span data-stu-id="7ad17-391">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7ad17-392">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7ad17-392">What we will build</span></span>

<span data-ttu-id="7ad17-393">以第4章為基礎，當具有沉浸式耳機的使用者接近島上的拼圖時，HoloLens 使用者將會取得工具提示，其中包含謎題的線索。</span><span class="sxs-lookup"><span data-stu-id="7ad17-393">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="7ad17-394">一旦所有的沉浸式耳機使用者都超過其謎題，並放到 rocket 室中的「就緒板」之後，rocket 就會啟動。</span><span class="sxs-lookup"><span data-stu-id="7ad17-394">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="7ad17-395">步驟</span><span class="sxs-lookup"><span data-stu-id="7ad17-395">Steps</span></span>

* <span data-ttu-id="7ad17-396">在 **[階層] 中選取**[ **Usland**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-396">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="7ad17-397">在 [ **檢查**] 的 [ **層級控制**] 中，勾選 [ **啟用** 共同作業]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-397">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7ad17-398">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7ad17-398">Digging into the code</span></span>

<span data-ttu-id="7ad17-399">現在讓我們看看 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="7ad17-399">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="7ad17-400">此腳本是遊戲邏輯的核心，可維持遊戲狀態。</span><span class="sxs-lookup"><span data-stu-id="7ad17-400">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="7ad17-401">由於這是使用 UNET 的多人遊戲，我們需要瞭解資料流程的運作方式，而且至少要有足夠的時間來修改本教學課程。</span><span class="sxs-lookup"><span data-stu-id="7ad17-401">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="7ad17-402">如需更完整的 UNET 總覽，請參閱 Unity 的檔。</span><span class="sxs-lookup"><span data-stu-id="7ad17-402">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="7ad17-403">在 [專案] 面板中，流覽至 [ **Assets\AppPrefabs\Support\Scripts\GameLogic** ]，然後按兩下 [ **LevelControl.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7ad17-403">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="7ad17-404">請讓我們瞭解沉浸式耳機如何表示已準備好開始 rocket。</span><span class="sxs-lookup"><span data-stu-id="7ad17-404">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="7ad17-405">Rocket 啟動準備工作的方式，是在對應到島上三個路徑的 bool 清單中設定三個 bool 的其中一個。</span><span class="sxs-lookup"><span data-stu-id="7ad17-405">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="7ad17-406">當指派給路徑的使用者位於 rocket 房間內棕色板的上方時，就會設定路徑的 bool。</span><span class="sxs-lookup"><span data-stu-id="7ad17-406">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="7ad17-407">好的，現在的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="7ad17-407">Okay, now to the details.</span></span>

<span data-ttu-id="7ad17-408">我們將從 Update ( # A1 函數開始。</span><span class="sxs-lookup"><span data-stu-id="7ad17-408">We will start in the Update() function.</span></span> <span data-ttu-id="7ad17-409">您將會注意到有「功能提要」功能。</span><span class="sxs-lookup"><span data-stu-id="7ad17-409">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="7ad17-410">我們在開發過程中使用此功能來測試 rocket 的啟動和重設順序。</span><span class="sxs-lookup"><span data-stu-id="7ad17-410">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="7ad17-411">它無法在多使用者體驗中使用。</span><span class="sxs-lookup"><span data-stu-id="7ad17-411">It won't work in the multi user experience.</span></span> <span data-ttu-id="7ad17-412">希望您旨在下列資訊的時間，您可以讓它正常運作。</span><span class="sxs-lookup"><span data-stu-id="7ad17-412">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="7ad17-413">在我們檢查看看是否有任何功能時，我們會檢查本機播放機是否可以沉浸。</span><span class="sxs-lookup"><span data-stu-id="7ad17-413">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="7ad17-414">我們希望專注于我們的目標。</span><span class="sxs-lookup"><span data-stu-id="7ad17-414">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="7ad17-415">在中，如果 (可以沉浸) 檢查，則會呼叫 CheckGoal 在 **EnableCollaboration** bool 後方隱藏。</span><span class="sxs-lookup"><span data-stu-id="7ad17-415">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="7ad17-416">這會對應到您在完成本章的步驟時所檢查的核取方塊。</span><span class="sxs-lookup"><span data-stu-id="7ad17-416">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="7ad17-417">在 EnableCollaboration 中，我們會看到 CheckGoal ( # A1 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="7ad17-417">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="7ad17-418">CheckGoal 會進行一些數學運算，以查看是否有更多或更少的站在板上。</span><span class="sxs-lookup"><span data-stu-id="7ad17-418">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="7ad17-419">當我們在進行時，我們會將「抵達目標」記錄檔，然後呼叫「SendAtGoalMessage ( # A1」。</span><span class="sxs-lookup"><span data-stu-id="7ad17-419">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="7ad17-420">在 SendAtGoalMessage 中，我們稱之為 >playercontroller. SendAtGoal。</span><span class="sxs-lookup"><span data-stu-id="7ad17-420">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="7ad17-421">為了節省時間，以下是程式碼：</span><span class="sxs-lookup"><span data-stu-id="7ad17-421">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
{
    levelState.SetGoalIndex(GoalIndex);
}
```

```cs
public void SendAtGoal(int GoalIndex)
{
    if (isLocalPlayer)
    {
        Debug.Log("sending at goal " + GoalIndex);
        CmdSendAtGoal(GoalIndex);
    }
}
```

<span data-ttu-id="7ad17-422">請注意，SendAtGoalMessage 會呼叫 CmdSendAtGoal，其會呼叫 levelState SetGoalIndex，這會傳回 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="7ad17-422">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="7ad17-423">乍看之下，這似乎很奇怪。</span><span class="sxs-lookup"><span data-stu-id="7ad17-423">At first glance this seems strange.</span></span> <span data-ttu-id="7ad17-424">為什麼不直接呼叫 SetGoalIndex，而不是透過 player 控制器來進行這種奇怪的路由？</span><span class="sxs-lookup"><span data-stu-id="7ad17-424">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="7ad17-425">原因是我們符合資料模型 UNET 用來保持資料同步。為了避免作弊並使其失效，UNET 要求每個物件都有一個具有變更已同步變數之許可權的使用者。</span><span class="sxs-lookup"><span data-stu-id="7ad17-425">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="7ad17-426">此外，只有主控制項 (啟動會話) 的使用者可以直接變更資料。</span><span class="sxs-lookup"><span data-stu-id="7ad17-426">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="7ad17-427">如果使用者不是主機，但具有授權單位，則必須將「命令」傳送至將變更變數的主控制項。</span><span class="sxs-lookup"><span data-stu-id="7ad17-427">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="7ad17-428">依預設，主機具有所有物件的許可權，但衍生來代表使用者的物件除外。</span><span class="sxs-lookup"><span data-stu-id="7ad17-428">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="7ad17-429">在我們的案例中，此物件具有 >playercontroller 腳本。</span><span class="sxs-lookup"><span data-stu-id="7ad17-429">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="7ad17-430">有一種方法可以要求物件的授權單位，然後進行變更，但我們選擇利用播放程式控制器具有自我授權，並透過 player 控制器路由傳送命令的事實。</span><span class="sxs-lookup"><span data-stu-id="7ad17-430">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="7ad17-431">另一種方式是，當我們找到自己的目標時，玩家需要告訴主機，而主機會告訴大家其他人。</span><span class="sxs-lookup"><span data-stu-id="7ad17-431">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="7ad17-432">回到 LevelControl.cs 查看 SetGoalIndex。</span><span class="sxs-lookup"><span data-stu-id="7ad17-432">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="7ad17-433">在這裡，我們要設定 synclist (AtGoal) 中值的值。</span><span class="sxs-lookup"><span data-stu-id="7ad17-433">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="7ad17-434">請記住，我們會在主機的內容中進行這項作業。</span><span class="sxs-lookup"><span data-stu-id="7ad17-434">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="7ad17-435">類似于命令，RPC 是主機可發出的內容，會導致所有用戶端執行一些程式碼。</span><span class="sxs-lookup"><span data-stu-id="7ad17-435">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="7ad17-436">在這裡，我們稱之為「RpcCheckAllGoals」。</span><span class="sxs-lookup"><span data-stu-id="7ad17-436">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="7ad17-437">每個用戶端都會個別檢查是否已設定全部三個 AtGoals，如果是，則啟動 rocket。</span><span class="sxs-lookup"><span data-stu-id="7ad17-437">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7ad17-438">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="7ad17-438">Enjoy your progress</span></span>

<span data-ttu-id="7ad17-439">在上一章中，我們將依之前的方式啟動會話。</span><span class="sxs-lookup"><span data-stu-id="7ad17-439">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="7ad17-440">這次，當沉浸式耳機中的使用者到達其路徑上的「門」時，就會出現只有 HoloLens 使用者可以看到的工具提示。</span><span class="sxs-lookup"><span data-stu-id="7ad17-440">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="7ad17-441">HoloLens 使用者負責將這個線索傳達給沉浸式耳機中的使用者。</span><span class="sxs-lookup"><span data-stu-id="7ad17-441">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="7ad17-442">一旦每個頭像在火山內的對應棕色板上進行了 rocket，就會啟動空間。</span><span class="sxs-lookup"><span data-stu-id="7ad17-442">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="7ad17-443">場景會在60秒後重設，以便您可以再次進行。</span><span class="sxs-lookup"><span data-stu-id="7ad17-443">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="7ad17-444">另請參閱</span><span class="sxs-lookup"><span data-stu-id="7ad17-444">See also</span></span>

* [<span data-ttu-id="7ad17-445">MR Input 213：運動控制器</span><span class="sxs-lookup"><span data-stu-id="7ad17-445">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)